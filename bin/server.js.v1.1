#!/usr/bin/env node
// ============================================
// LoxBerry Smart Irrigation Server
// Version 1.1 - mit Zeitplan-System
// ============================================

const express = require('express');
const sqlite3 = require('sqlite3').verbose();
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const axios = require('axios');
const path = require('path');
const fs = require('fs');
const cors = require('cors');
const cron = require('node-cron');
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(express.json());
app.use(cors());

// Statische Dateien
const webfrontendPath = path.join(__dirname, '..', 'webfrontend', 'html');
app.use(express.static(webfrontendPath));

// ============================================
// Globale Variablen
// ============================================
const dbPath = path.join(__dirname, '..', 'data', 'irrigation.db');
const configPath = path.join(__dirname, '..', 'config', 'config.json');

let db;
let config = {};
const activeTimers = new Map();
const activeCrons = new Map();

// ============================================
// Datenbank Initialisierung
// ============================================
function initDatabase() {
    console.log('üì¶ Initialisiere Datenbank...');
    
    db = new sqlite3.Database(dbPath, (err) => {
        if (err) {
            console.error('‚ùå Fehler beim √ñffnen der Datenbank:', err);
            process.exit(1);
        }
        console.log('‚úÖ Datenbank verbunden');
    });

    db.serialize(() => {
        // Users Tabelle
        db.run(`
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT UNIQUE NOT NULL,
                password TEXT NOT NULL,
                role TEXT DEFAULT 'user',
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);

        // Zones Tabelle
        db.run(`
            CREATE TABLE IF NOT EXISTS zones (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                position INTEGER,
                loxone_output TEXT,
                loxone_input TEXT,
                moisture INTEGER DEFAULT 0,
                is_active INTEGER DEFAULT 0,
                last_watered DATETIME,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);

        // Config Tabelle
        db.run(`
            CREATE TABLE IF NOT EXISTS config (
                key TEXT PRIMARY KEY,
                value TEXT,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);

        // Sequences Tabelle
        db.run(`
            CREATE TABLE IF NOT EXISTS sequences (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                zones TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);

        // Schedules Tabelle
        db.run(`
            CREATE TABLE IF NOT EXISTS schedules (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                sequence_id INTEGER NOT NULL,
                days TEXT NOT NULL,
                time TEXT NOT NULL,
                enabled INTEGER DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (sequence_id) REFERENCES sequences(id) ON DELETE CASCADE
            )
        `);

        // Default Zonen anlegen (falls noch nicht vorhanden)
        db.get('SELECT COUNT(*) as count FROM zones', [], (err, row) => {
            if (err) {
                console.error('Fehler beim Z√§hlen der Zonen:', err);
                return;
            }

            if (row.count === 0) {
                console.log('üìù Erstelle Standard-Zonen...');
                const stmt = db.prepare('INSERT INTO zones (name, loxone_output, loxone_input) VALUES (?, ?, ?)');
                
                for (let i = 1; i <= 12; i++) {
                    stmt.run(
                        `Zone ${i}`,
                        `IrrigationValve${i}`,
                        `IrrigationMoisture${i}`
                    );
                }
                
                stmt.finalize(() => {
                    console.log('‚úÖ 12 Standard-Zonen erstellt');
                });
            }
        });
    });

    // Config laden
    loadConfig();
}

// ============================================
// Config-Verwaltung
// ============================================
function loadConfig() {
    try {
        if (fs.existsSync(configPath)) {
            const configData = fs.readFileSync(configPath, 'utf8');
            config = JSON.parse(configData);
            console.log('‚úÖ Konfiguration geladen');
        } else {
            config = {
                initialized: false,
                loxone: {
                    host: '',
                    username: '',
                    password: ''
                },
                weather: {
                    apiKey: '',
                    lat: 48.2082,
                    lon: 16.3738
                }
            };
            saveConfig();
        }
    } catch (error) {
        console.error('Fehler beim Laden der Config:', error);
    }
}

function saveConfig() {
    try {
        fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
        console.log('‚úÖ Konfiguration gespeichert');
    } catch (error) {
        console.error('Fehler beim Speichern der Config:', error);
    }
}

// ============================================
// Loxone-Steuerung
// ============================================
async function controlZone(zoneId, state) {
    return new Promise((resolve, reject) => {
        db.get('SELECT * FROM zones WHERE id = ?', [zoneId], async (err, zone) => {
            if (err || !zone) {
                reject(new Error('Zone nicht gefunden'));
                return;
            }

            try {
                // Wenn Zone eingeschaltet werden soll, pr√ºfe ob andere Zone l√§uft
                if (state) {
                    const activeZone = await new Promise((res) => {
                        db.get('SELECT id, name FROM zones WHERE is_active = 1 AND id != ?', [zoneId], (err, row) => {
                            res(row);
                        });
                    });

                    if (activeZone) {
                        reject(new Error(`Zone "${activeZone.name}" l√§uft bereits. Bitte zuerst stoppen.`));
                        return;
                    }
                }

                // Loxone-Befehl senden (wenn konfiguriert)
                if (config.loxone && config.loxone.host && config.loxone.username) {
                    const loxoneUrl = `http://${config.loxone.host}/dev/sps/io/${zone.loxone_output}/${state ? 1 : 0}`;
                    
                    try {
                        await axios.get(loxoneUrl, {
                            auth: {
                                username: config.loxone.username,
                                password: config.loxone.password
                            },
                            timeout: 5000
                        });
                        console.log(`‚úÖ Loxone: ${zone.name} -> ${state ? 'AN' : 'AUS'}`);
                    } catch (loxoneError) {
                        console.error('‚ö†Ô∏è Loxone-Verbindungsfehler:', loxoneError.message);
                    }
                }

                // Datenbank aktualisieren
                const sql = state
                    ? 'UPDATE zones SET is_active = 1, last_watered = CURRENT_TIMESTAMP WHERE id = ?'
                    : 'UPDATE zones SET is_active = 0 WHERE id = ?';

                db.run(sql, [zoneId], (err) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    
                    console.log(`${state ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è'} Zone ${zone.name} ${state ? 'gestartet' : 'gestoppt'}`);
                    resolve({ success: true, zone: zone.name, state });
                });

            } catch (error) {
                reject(error);
            }
        });
    });
}

// ============================================
// Sequenz-Steuerung
// ============================================
async function runSequence(zones, sequenceId = null) {
    console.log('üîÑ Starte Sequenz mit Zonen:', zones);
    
    for (const zoneConfig of zones) {
        const zoneId = zoneConfig.zone_id;
        const duration = zoneConfig.duration;
        
        try {
            // Zone starten
            await controlZone(zoneId, true);
            console.log(`‚è±Ô∏è Zone ${zoneId} l√§uft f√ºr ${duration} Minuten`);
            
            // Warten
            await new Promise((resolve) => {
                setTimeout(async () => {
                    await controlZone(zoneId, false);
                    console.log(`‚úÖ Zone ${zoneId} beendet`);
                    resolve();
                }, duration * 60 * 1000);
            });
            
            // Kurze Pause zwischen Zonen
            await new Promise(resolve => setTimeout(resolve, 2000));
            
        } catch (error) {
            console.error(`‚ùå Fehler bei Zone ${zoneId}:`, error.message);
            // Bei Fehler trotzdem weitermachen mit n√§chster Zone
        }
    }
    
    console.log('‚úÖ Sequenz abgeschlossen');
}

// ============================================
// Cron-Job Verwaltung
// ============================================
async function loadScheduleCrons() {
    console.log('üïê Lade Zeitpl√§ne...');
    
    db.all('SELECT * FROM schedules WHERE enabled = 1', [], (err, schedules) => {
        if (err) {
            console.error('Fehler beim Laden der Zeitpl√§ne:', err);
            return;
        }
        
        schedules.forEach(schedule => {
            registerScheduleCron(schedule);
        });
        
        console.log(`‚úÖ ${schedules.length} aktive Zeitpl√§ne geladen`);
    });
}

function registerScheduleCron(schedule) {
    const cronKey = `schedule_${schedule.id}`;
    
    // Alten Cron stoppen falls vorhanden
    if (activeCrons.has(cronKey)) {
        activeCrons.get(cronKey).stop();
        activeCrons.delete(cronKey);
    }
    
    // Cron-Pattern erstellen
    const [hours, minutes] = schedule.time.split(':');
    const days = JSON.parse(schedule.days).join(',');
    const cronPattern = `${minutes} ${hours} * * ${days}`;
    
    console.log(`üìÖ Registriere Zeitplan #${schedule.id}: ${cronPattern}`);
    
    // Cron-Job erstellen
    const job = cron.schedule(cronPattern, async () => {
        console.log(`‚è∞ Zeitplan #${schedule.id} ausgel√∂st um ${new Date().toLocaleString('de-DE')}`);
        
        // Sequenz ausf√ºhren
        db.get('SELECT * FROM sequences WHERE id = ?', [schedule.sequence_id], async (err, sequence) => {
            if (err || !sequence) {
                console.error('Sequenz nicht gefunden:', schedule.sequence_id);
                return;
            }
            
            console.log(`üîÑ Starte Sequenz "${sequence.name}"`);
            const zones = JSON.parse(sequence.zones);
            await runSequence(zones, sequence.id);
        });
    }, {
        timezone: 'Europe/Vienna'
    });
    
    activeCrons.set(cronKey, job);
}

function reloadAllCrons() {
    console.log('üîÑ Lade alle Cron-Jobs neu...');
    
    // Alle stoppen
    activeCrons.forEach(job => job.stop());
    activeCrons.clear();
    
    // Neu laden
    loadScheduleCrons();
}

// ============================================
// API Routes - Zones
// ============================================
app.get('/api/zones', (req, res) => {
    db.all('SELECT * FROM zones ORDER BY id ASC', [], (err, zones) => {
        if (err) {
            console.error('Fehler beim Abrufen der Zonen:', err);
            return res.status(500).json({ error: err.message });
        }
        res.json(zones);
    });
});

app.post('/api/zones/:id/start', async (req, res) => {
    const { id } = req.params;
    const { duration = 10 } = req.body;

    try {
        await controlZone(id, true);

        // Auto-Stop Timer
        const timer = setTimeout(async () => {
            await controlZone(id, false);
            activeTimers.delete(parseInt(id));
        }, duration * 60 * 1000);

        activeTimers.set(parseInt(id), timer);

        res.json({
            success: true,
            message: `Zone ${id} gestartet f√ºr ${duration} Minuten`
        });
    } catch (error) {
        res.status(400).json({
            success: false,
            error: error.message
        });
    }
});

app.post('/api/zones/:id/stop', async (req, res) => {
    const { id } = req.params;

    try {
        // Timer l√∂schen falls vorhanden
        if (activeTimers.has(parseInt(id))) {
            clearTimeout(activeTimers.get(parseInt(id)));
            activeTimers.delete(parseInt(id));
        }

        await controlZone(id, false);

        res.json({
            success: true,
            message: `Zone ${id} gestoppt`
        });
    } catch (error) {
        res.status(400).json({
            success: false,
            error: error.message
        });
    }
});

app.post('/api/zones/stopall', async (req, res) => {
    try {
        // Alle Timer l√∂schen
        activeTimers.forEach(timer => clearTimeout(timer));
        activeTimers.clear();

        // Alle Zonen stoppen
        const zones = await new Promise((resolve, reject) => {
            db.all('SELECT id FROM zones WHERE is_active = 1', [], (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });

        for (const zone of zones) {
            await controlZone(zone.id, false);
        }

        res.json({
            success: true,
            message: `${zones.length} Zonen gestoppt`
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

app.put('/api/zones/:id', (req, res) => {
    const { id } = req.params;
    const { name } = req.body;

    if (!name) {
        return res.status(400).json({ error: 'Name erforderlich' });
    }

    db.run('UPDATE zones SET name = ? WHERE id = ?', [name, id], function(err) {
        if (err) {
            return res.status(500).json({ error: err.message });
        }

        if (this.changes === 0) {
            return res.status(404).json({ error: 'Zone nicht gefunden' });
        }

        res.json({
            success: true,
            message: 'Zone aktualisiert'
        });
    });
});

// ============================================
// API Routes - Sequences
// ============================================
app.get('/api/sequences', (req, res) => {
    db.all('SELECT * FROM sequences ORDER BY created_at DESC', [], (err, sequences) => {
        if (err) {
            console.error('Fehler beim Abrufen der Sequenzen:', err);
            return res.status(500).json({ error: err.message });
        }
        
        // Zones-String in Array parsen
        const parsedSequences = sequences.map(seq => ({
            ...seq,
            zones: JSON.parse(seq.zones)
        }));
        
        res.json(parsedSequences);
    });
});

app.post('/api/sequences', (req, res) => {
    const { name, zones } = req.body;

    if (!name || !zones || zones.length === 0) {
        return res.status(400).json({ error: 'Name und Zonen erforderlich' });
    }

    const zonesJson = JSON.stringify(zones);

    db.run(
        'INSERT INTO sequences (name, zones) VALUES (?, ?)',
        [name, zonesJson],
        function(err) {
            if (err) {
                console.error('Fehler beim Erstellen der Sequenz:', err);
                return res.status(500).json({ error: err.message });
            }

            console.log(`‚úÖ Sequenz erstellt: ${name} (ID: ${this.lastID})`);
            
            res.json({
                success: true,
                id: this.lastID,
                message: 'Sequenz erstellt'
            });
        }
    );
});

app.delete('/api/sequences/:id', (req, res) => {
    const { id } = req.params;

    db.run('DELETE FROM sequences WHERE id = ?', [id], function(err) {
        if (err) {
            console.error('Fehler beim L√∂schen der Sequenz:', err);
            return res.status(500).json({ error: err.message });
        }

        if (this.changes === 0) {
            return res.status(404).json({ error: 'Sequenz nicht gefunden' });
        }

        console.log(`‚úÖ Sequenz gel√∂scht: #${id}`);
        
        res.json({
            success: true,
            message: 'Sequenz gel√∂scht'
        });
    });
});

app.post('/api/sequences/:id/start', async (req, res) => {
    const { id } = req.params;

    try {
        const sequence = await new Promise((resolve, reject) => {
            db.get('SELECT * FROM sequences WHERE id = ?', [id], (err, row) => {
                if (err) reject(err);
                else if (!row) reject(new Error('Sequenz nicht gefunden'));
                else resolve(row);
            });
        });

        const zones = JSON.parse(sequence.zones);

        // Sequenz im Hintergrund starten
        runSequence(zones, sequence.id).catch(err => {
            console.error('Fehler beim Ausf√ºhren der Sequenz:', err);
        });

        res.json({
            success: true,
            message: `Sequenz "${sequence.name}" gestartet`,
            zones: zones.length
        });

    } catch (error) {
        res.status(400).json({
            success: false,
            error: error.message
        });
    }
});

// ============================================
// API Routes - Schedules
// ============================================
app.get('/api/schedules', (req, res) => {
    db.all('SELECT * FROM schedules ORDER BY time ASC', [], (err, schedules) => {
        if (err) {
            console.error('Fehler beim Abrufen der Zeitpl√§ne:', err);
            return res.status(500).json({ error: err.message });
        }
        res.json(schedules);
    });
});

app.post('/api/schedules', (req, res) => {
    const { name, sequence_id, days, time, enabled } = req.body;
    
    if (!sequence_id || !days || !time) {
        return res.status(400).json({ error: 'Fehlende Daten' });
    }
    
    const sql = `
        INSERT INTO schedules (name, sequence_id, days, time, enabled)
        VALUES (?, ?, ?, ?, ?)
    `;
    
    db.run(sql, [name, sequence_id, days, time, enabled ?? 1], function(err) {
        if (err) {
            console.error('Fehler beim Erstellen des Zeitplans:', err);
            return res.status(500).json({ error: err.message });
        }
        
        console.log(`‚úÖ Zeitplan erstellt: #${this.lastID}`);
        
        // Crons neu laden
        reloadAllCrons();
        
        res.json({ 
            success: true, 
            id: this.lastID,
            message: 'Zeitplan erstellt'
        });
    });
});

app.put('/api/schedules/:id', (req, res) => {
    const { id } = req.params;
    const { name, sequence_id, days, time, enabled } = req.body;
    
    // Nur √ºbergebene Felder updaten
    const updates = [];
    const values = [];
    
    if (name !== undefined) { updates.push('name = ?'); values.push(name); }
    if (sequence_id !== undefined) { updates.push('sequence_id = ?'); values.push(sequence_id); }
    if (days !== undefined) { updates.push('days = ?'); values.push(days); }
    if (time !== undefined) { updates.push('time = ?'); values.push(time); }
    if (enabled !== undefined) { updates.push('enabled = ?'); values.push(enabled); }
    
    if (updates.length === 0) {
        return res.status(400).json({ error: 'Keine Daten zum Aktualisieren' });
    }
    
    values.push(id);
    const sql = `UPDATE schedules SET ${updates.join(', ')} WHERE id = ?`;
    
    db.run(sql, values, function(err) {
        if (err) {
            console.error('Fehler beim Aktualisieren des Zeitplans:', err);
            return res.status(500).json({ error: err.message });
        }
        
        if (this.changes === 0) {
            return res.status(404).json({ error: 'Zeitplan nicht gefunden' });
        }
        
        console.log(`‚úÖ Zeitplan aktualisiert: #${id}`);
        
        // Crons neu laden
        reloadAllCrons();
        
        res.json({ 
            success: true,
            message: 'Zeitplan aktualisiert'
        });
    });
});

app.delete('/api/schedules/:id', (req, res) => {
    const { id } = req.params;
    
    db.run('DELETE FROM schedules WHERE id = ?', [id], function(err) {
        if (err) {
            console.error('Fehler beim L√∂schen des Zeitplans:', err);
            return res.status(500).json({ error: err.message });
        }
        
        if (this.changes === 0) {
            return res.status(404).json({ error: 'Zeitplan nicht gefunden' });
        }
        
        console.log(`‚úÖ Zeitplan gel√∂scht: #${id}`);
        
        // Crons neu laden
        reloadAllCrons();
        
        res.json({ 
            success: true,
            message: 'Zeitplan gel√∂scht'
        });
    });
});

// ============================================
// API Routes - Setup
// ============================================
app.get('/api/setup/config', (req, res) => {
    res.json(config);
});

app.post('/api/setup/save', (req, res) => {
    try {
        const { loxone, weather, zones } = req.body;

        if (loxone) {
            config.loxone = loxone;
        }

        if (weather) {
            config.weather = weather;
        }

        if (zones && Array.isArray(zones)) {
            const stmt = db.prepare('UPDATE zones SET name = ? WHERE id = ?');
            zones.forEach(zone => {
                stmt.run(zone.name, zone.id);
            });
            stmt.finalize();
        }

        config.initialized = true;
        saveConfig();

        res.json({
            success: true,
            message: 'Konfiguration gespeichert'
        });
    } catch (error) {
        console.error('Fehler beim Speichern der Setup-Daten:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

app.post('/api/setup/test-connection', async (req, res) => {
    try {
        const { host, username, password } = req.body;

        if (!host || !username || !password) {
            return res.status(400).json({
                success: false,
                error: 'Alle Felder sind erforderlich'
            });
        }

        const testUrl = `http://${host}/dev/sps/status`;

        const response = await axios.get(testUrl, {
            auth: { username, password },
            timeout: 5000
        });

        res.json({
            success: true,
            message: 'Verbindung erfolgreich',
            data: response.data
        });

    } catch (error) {
        console.error('Verbindungstest fehlgeschlagen:', error);

        let errorMessage = 'Verbindung fehlgeschlagen';
        if (error.code === 'ECONNREFUSED') {
            errorMessage = 'Miniserver nicht erreichbar';
        } else if (error.response?.status === 401) {
            errorMessage = 'Benutzername oder Passwort falsch';
        } else if (error.code === 'ETIMEDOUT') {
            errorMessage = 'Timeout - Miniserver antwortet nicht';
        }

        res.status(400).json({
            success: false,
            error: errorMessage
        });
    }
});

// ============================================
// Server Start
// ============================================
app.listen(PORT, () => {
    console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
    console.log('‚ïë  üå± LoxBerry Smart Irrigation v1.1  ‚ïë');
    console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
    console.log(`‚úÖ Server l√§uft auf Port ${PORT}`);
    console.log(`üåê Web-UI: http://localhost:${PORT}`);
    console.log('');
    
    initDatabase();
    
    // Warte kurz bis DB initialisiert ist, dann lade Crons
    setTimeout(() => {
        loadScheduleCrons();
    }, 1000);
});

// Graceful Shutdown
process.on('SIGINT', () => {
    console.log('\n‚èπÔ∏è Server wird beendet...');
    
    // Alle Timer stoppen
    activeTimers.forEach(timer => clearTimeout(timer));
    activeTimers.clear();
    
    // Alle Crons stoppen
    activeCrons.forEach(job => job.stop());
    activeCrons.clear();
    
    // Datenbank schlie√üen
    db.close((err) => {
        if (err) {
            console.error('Fehler beim Schlie√üen der Datenbank:', err);
        } else {
            console.log('‚úÖ Datenbank geschlossen');
        }
        process.exit(0);
    });
});
